// Code generated by s4bmongo. DO NOT EDIT.
package tests

import (
	"context"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"net/url"
	"os"
	"sync"
)

type UserRepository interface {
	FindOne(ctx context.Context, findQuery bson.M) (*User, error)
	FindOneById(ctx context.Context, id string) (*User, error)
	FindMany(ctx context.Context, findQuery bson.M, skip, limit int64) ([]*User, error)
	InsertOne(ctx context.Context, record *User) (InsertedID primitive.ObjectID, err error)
	InsertMany(ctx context.Context, records []*User) (InsertedID []primitive.ObjectID, err error)
	DeleteOne(ctx context.Context, findQuery bson.M) (delete int64, err error)
	DeleteMany(ctx context.Context, findQuery bson.M) (delete int64, err error)
	Watch(pipeline mongo.Pipeline) (<-chan UserChangeEvent, error)
}

type usersRepository struct {
	client *mongo.Client
	ctx    context.Context
	c      *mongo.Collection
}

func NewUserRepositoryDefault(ctx context.Context) UserRepository {
	cs := os.Getenv("MONGODB_CONNECTION_STRING")
	if cs == "" {
		cs = "mongodb://db1:30002,db2:30001/ipo?replicaSet=rs&readPreference=primaryPreferred"
	}

	return NewUserRepository(ctx, cs)
}

func NewUserRepository(ctx context.Context, cs string) UserRepository {
	u, err := url.Parse(cs)
	if err != nil {
		panic(err)
	}

	client, err := mongo.Connect(ctx, options.Client().ApplyURI(cs))
	if err != nil {
		panic(err)
	}
	database := client.Database(u.Path[1:])
	return &usersRepository{
		client: client,
		ctx:    ctx,
		c:      database.Collection("users"),
	}
}

func (s *usersRepository) FindMany(ctx context.Context, findQuery bson.M, skip, limit int64) ([]*User, error) {
	opts := &options.FindOptions{}
	opts.SetLimit(limit)
	opts.SetSkip(skip)

	cursor, err := s.c.Find(ctx, findQuery, opts)
	if err != nil {
		return nil, err
	}
	records := make([]*User, 0, limit)
	for cursor.Next(ctx) {
		t := User{}
		err := cursor.Decode(&t)
		if err != nil {
			return records, err
		}
		records = append(records, &t)
	}

	return records, nil
}

func (s *usersRepository) FindOne(ctx context.Context, findQuery bson.M) (*User, error) {
	var r User
	if err := s.c.FindOne(ctx, findQuery).Decode(&r); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return &r, nil
}

func (s *usersRepository) FindOneById(ctx context.Context, id string) (*User, error) {
	prim, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	var r User
	if err := s.c.FindOne(ctx, bson.M{"_id": prim}).Decode(&r); err != nil {
		return nil, err
	}
	return &r, nil
}

func (s *usersRepository) InsertOne(ctx context.Context, record *User) (InsertedID primitive.ObjectID, err error) {
	res, err := s.c.InsertOne(ctx, record)
	if err != nil {
		return primitive.ObjectID{}, err
	}
	return res.InsertedID.(primitive.ObjectID), err
}

func (s *usersRepository) InsertMany(ctx context.Context, records []*User) (InsertedID []primitive.ObjectID, err error) {
	data := make([]interface{}, len(records))
	for i := range records {
		data[i] = records[i]
	}
	res, err := s.c.InsertMany(ctx, data)
	if err != nil {
		return []primitive.ObjectID{}, err
	}
	ids := make([]primitive.ObjectID, len(res.InsertedIDs))
	for i := range res.InsertedIDs {
		ids[i] = res.InsertedIDs[i].(primitive.ObjectID)
	}
	return ids, err
}

func (s *usersRepository) DeleteOne(ctx context.Context, findQuery bson.M) (delete int64, err error) {
	res, err := s.c.DeleteOne(ctx, findQuery)
	if err != nil {
		return 0, err
	}
	return res.DeletedCount, nil
}

func (s *usersRepository) DeleteMany(ctx context.Context, findQuery bson.M) (delete int64, err error) {
	res, err := s.c.DeleteMany(ctx, findQuery)
	if err != nil {
		return 0, err
	}
	return res.DeletedCount, nil
}

func (s *usersRepository) Watch(pipeline mongo.Pipeline) (<-chan UserChangeEvent, error) {
	updateLookup := options.UpdateLookup
	opts1 := &options.ChangeStreamOptions{
		FullDocument: &updateLookup,
	}
	stream, err := s.c.Watch(s.ctx, pipeline, opts1)
	if err != nil {
		return nil, err
	}
	var wg sync.WaitGroup
	ch := make(chan UserChangeEvent)
	go func() {
		wg.Add(1)
		defer wg.Done()
		for {
			select {
			case <-s.ctx.Done():
				close(ch)
			default:
				iterateUserChangeStream(s.ctx, stream, ch)
			}
		}
	}()
	wg.Wait()
	return ch, nil
}

func iterateUserChangeStream(ctx context.Context, stream *mongo.ChangeStream, ch chan<- UserChangeEvent) {
	for stream.Next(ctx) {
		var data UserChangeEvent
		if err := stream.Decode(&data); err != nil {
			continue
		}
		ch <- data
	}
}

type UserChangeEvent struct {
	ID struct {
		Data string `bson:"_data"`
	} `bson:"_id"`
	OperationType string              `bson:"operationType"`
	ClusterTime   primitive.Timestamp `bson:"clusterTime"`
	FullDocument  *User               `bson:"fullDocument"`
	DocumentKey   struct {
		ID primitive.ObjectID `bson:"_id"`
	} `bson:"documentKey"`
	Ns struct {
		Db   string `bson:"db"`
		Coll string `bson:"coll"`
	} `bson:"ns"`
}
