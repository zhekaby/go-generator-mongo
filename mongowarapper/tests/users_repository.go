// Code generated by mongowarapper. DO NOT EDIT.
package tests

import (
	"context"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
	"net/url"
	"os"
	"sync"
	"time"
)

type UserRepository interface {
	Ping() error
	FindOne(ctx context.Context, findQuery bson.M) (*User, error)
	FindOneById(ctx context.Context, id string) (*User, error)
	FindMany(ctx context.Context, findQuery bson.M, sort bson.D, skip, limit int64) ([]*User, error)
	InsertOne(ctx context.Context, record *User) (InsertedID primitive.ObjectID, err error)
	InsertMany(ctx context.Context, records []*User) (InsertedID []primitive.ObjectID, err error)
	UpdateOne(ctx context.Context, findQuery, updateQuery bson.M) (matched bool, modified bool, err error)
	UpdateOneById(ctx context.Context, id string, updateQuery bson.M) (matched bool, modified bool, err error)
	UpdateOneFluent(ctx context.Context, findQuery bson.M, updater UserUpdater) (matched bool, modified bool, err error)
	UpdateOneByIdFluent(ctx context.Context, id string, updater UserUpdater) (matched bool, modified bool, err error)
	DeleteOne(ctx context.Context, findQuery bson.M) (isDeleted bool, err error)
	DeleteOneById(ctx context.Context, id string) (isDeleted bool, err error)
	DeleteMany(ctx context.Context, findQuery bson.M) (delete int64, err error)
	Watch(pipeline mongo.Pipeline) (<-chan UserChangeEvent, error)
}

type usersRepository struct {
	client *mongo.Client
	ctx    context.Context
	c      *mongo.Collection
}

func NewUserRepositoryDefault(ctx context.Context) UserRepository {
	cs := os.Getenv("MONGODB_CONNECTION_STRING")

	if cs == "" {
		cs = "mongodb://db1:33001,db2:33002/ipo?replicaSet=mongowarapper-tests&readPreference=primaryPreferred"
	}

	return NewUserRepository(ctx, cs)
}

func NewUserRepository(ctx context.Context, cs string) UserRepository {
	client, err := mongo.Connect(ctx, options.Client().ApplyURI(cs))
	if err != nil {
		panic(err)
	}

	u, err := url.Parse(cs)
	if err != nil {
		panic(err)
	}
	database := client.Database(u.Path[1:])

	return &usersRepository{
		client: client,
		ctx:    ctx,
		c:      database.Collection("users"),
	}
}

func (s *usersRepository) Ping() error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	return s.client.Ping(ctx, readpref.Primary())
}

func (s *usersRepository) FindMany(ctx context.Context, findQuery bson.M, sort bson.D, skip, limit int64) ([]*User, error) {
	opts := &options.FindOptions{}
	opts.SetLimit(limit)
	opts.SetSkip(skip)
	opts.SetSort(sort)

	if cursor, err := s.c.Find(ctx, findQuery, opts); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	} else {
		records := make([]*User, 0, limit)
		for cursor.Next(ctx) {
			t := User{}
			err := cursor.Decode(&t)
			if err != nil {
				return records, err
			}
			records = append(records, &t)
		}
		return records, nil
	}
}

func (s *usersRepository) FindOne(ctx context.Context, findQuery bson.M) (*User, error) {
	var r User
	if err := s.c.FindOne(ctx, findQuery).Decode(&r); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return &r, nil
}

func (s *usersRepository) FindOneById(ctx context.Context, id string) (*User, error) {
	prim, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	var r User
	if err := s.c.FindOne(ctx, bson.M{"_id": prim}).Decode(&r); err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return &r, nil
}

func (s *usersRepository) InsertOne(ctx context.Context, record *User) (InsertedID primitive.ObjectID, err error) {
	res, err := s.c.InsertOne(ctx, record)
	if err != nil {
		return primitive.ObjectID{}, err
	}
	return res.InsertedID.(primitive.ObjectID), err
}

func (s *usersRepository) InsertMany(ctx context.Context, records []*User) (InsertedID []primitive.ObjectID, err error) {
	data := make([]interface{}, len(records))
	for i := range records {
		data[i] = records[i]
	}
	res, err := s.c.InsertMany(ctx, data)
	if err != nil {
		return []primitive.ObjectID{}, err
	}
	ids := make([]primitive.ObjectID, len(res.InsertedIDs))
	for i := range res.InsertedIDs {
		ids[i] = res.InsertedIDs[i].(primitive.ObjectID)
	}
	return ids, err
}

func (s *usersRepository) UpdateOne(ctx context.Context, findQuery, updateQuery bson.M) (matched bool, modified bool, err error) {
	if res, err := s.c.UpdateOne(ctx, findQuery, updateQuery); err != nil {
		return false, false, err
	} else {
		return res.MatchedCount > 0, res.ModifiedCount > 0, nil
	}
}

func (s *usersRepository) UpdateOneById(ctx context.Context, id string, updateQuery bson.M) (matched bool, modified bool, err error) {
	if bsonId, err := primitive.ObjectIDFromHex(id); err != nil {
		return false, false, err
	} else {
		if res, err := s.c.UpdateOne(ctx, bson.M{"_id": bsonId}, updateQuery); err != nil {
			return false, false, err
		} else {
			return res.MatchedCount > 0, res.ModifiedCount > 0, nil
		}
	}
}

func (s *usersRepository) UpdateOneFluent(ctx context.Context, findQuery bson.M, updater UserUpdater) (matched bool, modified bool, err error) {
	if res, err := s.c.UpdateOne(ctx, findQuery, updater.(*users_updater).compile()); err != nil {
		return false, false, err
	} else {
		return res.MatchedCount > 0, res.ModifiedCount > 0, nil
	}
}

func (s *usersRepository) UpdateOneByIdFluent(ctx context.Context, id string, updater UserUpdater) (matched bool, modified bool, err error) {
	if bsonId, err := primitive.ObjectIDFromHex(id); err != nil {
		return false, false, err
	} else {
		if res, err := s.c.UpdateOne(ctx, bson.M{"_id": bsonId}, updater.(*users_updater).compile()); err != nil {
			return false, false, err
		} else {
			return res.MatchedCount > 0, res.ModifiedCount > 0, nil
		}
	}
}

func (s *usersRepository) DeleteOne(ctx context.Context, findQuery bson.M) (isDeleted bool, err error) {
	res, err := s.c.DeleteOne(ctx, findQuery)
	if err != nil {
		return false, err
	}
	return res.DeletedCount > 0, nil
}

func (s *usersRepository) DeleteOneById(ctx context.Context, id string) (isDeleted bool, err error) {
	if bsonId, err := primitive.ObjectIDFromHex(id); err != nil {
		return false, err
	} else {
		res, err := s.c.DeleteOne(ctx, bson.M{"_id": bsonId})
		if err != nil {
			return false, err
		}
		return res.DeletedCount > 0, nil
	}
}

func (s *usersRepository) DeleteMany(ctx context.Context, findQuery bson.M) (delete int64, err error) {
	res, err := s.c.DeleteMany(ctx, findQuery)
	if err != nil {
		return 0, err
	}
	return res.DeletedCount, nil
}

func (s *usersRepository) Watch(pipeline mongo.Pipeline) (<-chan UserChangeEvent, error) {
	updateLookup := options.UpdateLookup
	opts1 := &options.ChangeStreamOptions{
		FullDocument: &updateLookup,
	}
	stream, err := s.c.Watch(s.ctx, pipeline, opts1)
	if err != nil {
		return nil, err
	}
	var wg sync.WaitGroup
	ch := make(chan UserChangeEvent)
	go func() {
		wg.Add(1)
		defer wg.Done()
		for {
			select {
			case <-s.ctx.Done():
				close(ch)
			default:
				iterateUserChangeStream(s.ctx, stream, ch)
			}
		}
	}()
	wg.Wait()
	return ch, nil
}

func iterateUserChangeStream(ctx context.Context, stream *mongo.ChangeStream, ch chan<- UserChangeEvent) {
	for stream.Next(ctx) {
		var data UserChangeEvent
		if err := stream.Decode(&data); err != nil {
			continue
		}
		ch <- data
	}
}

type UserChangeEvent struct {
	ID struct {
		Data string `bson:"_data"`
	} `bson:"_id"`
	OperationType string              `bson:"operationType"`
	ClusterTime   primitive.Timestamp `bson:"clusterTime"`
	FullDocument  *User               `bson:"fullDocument"`
	DocumentKey   struct {
		ID primitive.ObjectID `bson:"_id"`
	} `bson:"documentKey"`
	Ns struct {
		Db   string `bson:"db"`
		Coll string `bson:"coll"`
	} `bson:"ns"`
}

type UserUpdater interface {
	SetEmail(vEmail string) UserUpdater

	SetProfile(vProfile Profile) UserUpdater

	SetProfileFirstName(vFirstName string) UserUpdater

	SetProfileLastName(vLastName string) UserUpdater

	SetAddressCity(vCity string) UserUpdater

	SetFinIncome(vIncome int64) UserUpdater
}

type users_updater struct {
	updates bson.M
}

func NewUserUpdater() UserUpdater {
	return &users_updater{
		updates: bson.M{},
	}
}

func (u *users_updater) compile() bson.M {
	return bson.M{"$set": u.updates}
}

func (u *users_updater) SetEmail(vEmail string) UserUpdater {
	u.updates["email"] = vEmail
	return u
}

func (u *users_updater) SetProfile(vProfile Profile) UserUpdater {
	u.updates["profile"] = vProfile
	return u
}

func (u *users_updater) SetProfileFirstName(vFirstName string) UserUpdater {
	u.updates["profile.first_name"] = vFirstName
	return u
}

func (u *users_updater) SetProfileLastName(vLastName string) UserUpdater {
	u.updates["profile.last_name"] = vLastName
	return u
}

func (u *users_updater) SetAddressCity(vCity string) UserUpdater {
	u.updates["address.City"] = vCity
	return u
}

func (u *users_updater) SetFinIncome(vIncome int64) UserUpdater {
	u.updates["Fin.Income"] = vIncome
	return u
}
