// Code generated by requestwaraper. DO NOT EDIT.
package tests

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/go-playground/validator/v10"
	"io/ioutil"
	"net/http"
)

var packageValidator = validator.New()

var requestwarapper_deviceCreateRequestParamsMap = map[string]string{
	"item.UserID":   "user_id",
	"item.Locale":   "locale",
	"item.Num":      "num",
	"item.Type":     "type",
	"item.Assn":     "assn",
	"item.Assn1":    "assn1",
	"item.MyData.N": "MyData.N",
}

func deviceCreateRequestParamsValidator(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var body item
		bytes, err := ioutil.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("cant read body"))
			return
		}
		if err := body.UnmarshalJSON(bytes); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(fmt.Sprintf("invalid json: %s", err)))
			return
		}
		err = packageValidator.Struct(body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			verrs := err.(validator.ValidationErrors)
			m := make(map[string][]interface{}, len(verrs))
			for _, e := range verrs {
				n := requestwarapper_deviceCreateRequestParamsMap[e.Namespace()]
				v, ok := m[n]
				if !ok {
					v = make([]interface{}, 0, 5)
				}
				if e.Tag() == "required" {
					v = append(v, &requestwarapper_error_key_default{
						Key: e.Tag(),
					})
					m[n] = v
					continue
				}
				switch e.Namespace() {

				case "item.Num":
					switch e.Tag() {

					case "max":
						v = append(v, requestwarapper_error_deviceCreateRequestParams_itemNum_max)
					case "min":
						v = append(v, requestwarapper_error_deviceCreateRequestParams_itemNum_min)
					}

				case "item.Assn":
					switch e.Tag() {

					case "required_without_all":
						v = append(v, requestwarapper_error_deviceCreateRequestParams_itemAssn_required_without_all)
					}

				case "item.Assn1":
					switch e.Tag() {

					case "required_without_all":
						v = append(v, requestwarapper_error_deviceCreateRequestParams_itemAssn1_required_without_all)
					}

				}
				m[n] = v
			}
			b, _ := json.Marshal(&requestwarapper_error_model{
				Errors: m,
			})
			w.Write(b)
			return
		}
		next.ServeHTTP(w, r.WithContext(context.WithValue(r.Context(), "body", &body)))
	})
}

var requestwarapper_error_deviceCreateRequestParams_itemNum_min = struct {
	Key   string  `json:"key"`
	Value float64 `json:"value"`
}{
	Value: 4,
	Key:   "min",
}
var requestwarapper_error_deviceCreateRequestParams_itemNum_max = struct {
	Key   string  `json:"key"`
	Value float64 `json:"value"`
}{
	Value: 15,
	Key:   "max",
}
var requestwarapper_error_deviceCreateRequestParams_itemAssn_required_without_all = struct {
	Key string `json:"key"`
}{
	Key: "required_without_all",
}
var requestwarapper_error_deviceCreateRequestParams_itemAssn1_required_without_all = struct {
	Key string `json:"key"`
}{
	Key: "required_without_all",
}

var requestwarapper_DeviceCreateRequestParamsMap = map[string]string{
	"device.UserID":          "user_id",
	"device.Locale":          "locale",
	"device.Type":            "type",
	"device.NativePushToken": "native_push_token",
	"device.NativeVoIPToken": "native_voip_token",
	"device.Carrier":         "carrier",
	"device.Mcc":             "mcc",
	"device.Mnc":             "mnc",
	"device.OsVersion":       "os_version",
	"device.BuildNumber":     "build_number",
	"device.AppVersion":      "app_version",
	"device.CountryCode":     "country_code",
	"device.PhoneNumber":     "phone_number",
	"device.Mode":            "mode",
}

func DeviceCreateRequestParamsValidator(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var body device
		bytes, err := ioutil.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("cant read body"))
			return
		}
		if err := body.UnmarshalJSON(bytes); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(fmt.Sprintf("invalid json: %s", err)))
			return
		}
		err = packageValidator.Struct(body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			verrs := err.(validator.ValidationErrors)
			m := make(map[string][]interface{}, len(verrs))
			for _, e := range verrs {
				n := requestwarapper_DeviceCreateRequestParamsMap[e.Namespace()]
				v, ok := m[n]
				if !ok {
					v = make([]interface{}, 0, 5)
				}
				if e.Tag() == "required" {
					v = append(v, &requestwarapper_error_key_default{
						Key: e.Tag(),
					})
					m[n] = v
					continue
				}
				switch e.Namespace() {

				case "device.NativePushToken":
					switch e.Tag() {

					case "required_without_all":
						v = append(v, requestwarapper_error_DeviceCreateRequestParams_deviceNativePushToken_required_without_all)
					}

				case "device.NativeVoIPToken":
					switch e.Tag() {

					case "required_without_all":
						v = append(v, requestwarapper_error_DeviceCreateRequestParams_deviceNativeVoIPToken_required_without_all)
					}

				}
				m[n] = v
			}
			b, _ := json.Marshal(&requestwarapper_error_model{
				Errors: m,
			})
			w.Write(b)
			return
		}
		next.ServeHTTP(w, r.WithContext(context.WithValue(r.Context(), "body", &body)))
	})
}

var requestwarapper_error_DeviceCreateRequestParams_deviceNativePushToken_required_without_all = struct {
	Key string `json:"key"`
}{
	Key: "required_without_all",
}
var requestwarapper_error_DeviceCreateRequestParams_deviceNativeVoIPToken_required_without_all = struct {
	Key string `json:"key"`
}{
	Key: "required_without_all",
}

type requestwarapper_error_model struct {
	Errors map[string][]interface{} `json:"errors"`
}
type requestwarapper_error_key_default struct {
	Key string `json:"key"`
}
